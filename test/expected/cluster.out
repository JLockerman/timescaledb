CREATE TABLE cluster_test(time timestamptz, temp float, location int);
SELECT create_hypertable('cluster_test', 'time', chunk_time_interval => interval '1 day');
NOTICE:  adding not-null constraint to column "time"
 create_hypertable 
-------------------
 
(1 row)

-- Show default indexes
SELECT * FROM test.show_indexes('cluster_test');
         Index         | Columns | Unique | Primary | Exclusion | Tablespace 
-----------------------+---------+--------+---------+-----------+------------
 cluster_test_time_idx | {time}  | f      | f       | f         | 
(1 row)

-- Create two chunks
INSERT INTO cluster_test VALUES ('2017-01-20T09:00:01', 23.4, 1),
       ('2017-01-21T09:00:01', 21.3, 2);
-- after each test we ensure bitmap scans work
BEGIN;
    SET LOCAL enable_seqscan=false;
    SET LOCAL enable_indexscan=false;
    SET LOCAL enable_bitmapscan=true;
    EXPLAIN (costs off) SELECT * FROM cluster_test WHERE time='2017-01-21T09:00:01';
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 Append
   ->  Bitmap Heap Scan on cluster_test
         Recheck Cond: ("time" = 'Sat Jan 21 09:00:01 2017 PST'::timestamp with time zone)
         ->  Bitmap Index Scan on cluster_test_time_idx
               Index Cond: ("time" = 'Sat Jan 21 09:00:01 2017 PST'::timestamp with time zone)
   ->  Bitmap Heap Scan on _hyper_1_2_chunk
         Recheck Cond: ("time" = 'Sat Jan 21 09:00:01 2017 PST'::timestamp with time zone)
         ->  Bitmap Index Scan on _hyper_1_2_chunk_cluster_test_time_idx
               Index Cond: ("time" = 'Sat Jan 21 09:00:01 2017 PST'::timestamp with time zone)
(9 rows)

    SELECT * FROM cluster_test WHERE time='2017-01-21T09:00:01';
             time             | temp | location 
------------------------------+------+----------
 Sat Jan 21 09:00:01 2017 PST | 21.3 |        2
(1 row)

COMMIT;
-- after each test we ensure index scans work
BEGIN;
    SET LOCAL enable_seqscan=false;
    SET LOCAL enable_indexscan=true;
    SET LOCAL enable_bitmapscan=false;
    EXPLAIN (costs off) SELECT * FROM cluster_test WHERE time='2017-01-21T09:00:01';
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Append
   ->  Index Scan using cluster_test_time_idx on cluster_test
         Index Cond: ("time" = 'Sat Jan 21 09:00:01 2017 PST'::timestamp with time zone)
   ->  Index Scan using _hyper_1_2_chunk_cluster_test_time_idx on _hyper_1_2_chunk
         Index Cond: ("time" = 'Sat Jan 21 09:00:01 2017 PST'::timestamp with time zone)
(5 rows)

    SELECT * FROM cluster_test WHERE time='2017-01-21T09:00:01';
             time             | temp | location 
------------------------------+------+----------
 Sat Jan 21 09:00:01 2017 PST | 21.3 |        2
(1 row)

COMMIT;
-- after each test we ensure sequntial scans work
BEGIN;
    SET LOCAL enable_seqscan=true;
    SET LOCAL enable_indexscan=false;
    SET LOCAL enable_bitmapscan=false;
    EXPLAIN (costs off) SELECT * FROM cluster_test WHERE time='2017-01-21T09:00:01';
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Append
   ->  Seq Scan on cluster_test
         Filter: ("time" = 'Sat Jan 21 09:00:01 2017 PST'::timestamp with time zone)
   ->  Seq Scan on _hyper_1_2_chunk
         Filter: ("time" = 'Sat Jan 21 09:00:01 2017 PST'::timestamp with time zone)
(5 rows)

    SELECT * FROM cluster_test WHERE time='2017-01-21T09:00:01';
             time             | temp | location 
------------------------------+------+----------
 Sat Jan 21 09:00:01 2017 PST | 21.3 |        2
(1 row)

COMMIT;
-- Run cluster
CLUSTER VERBOSE cluster_test USING cluster_test_time_idx;
INFO:  reclustering "_timescaledb_internal._hyper_1_2_chunk" using index scan on "_hyper_1_2_chunk_cluster_test_time_idx"
INFO:  "_hyper_1_2_chunk": found 0 removable, 1 nonremovable row versions in 1 pages
INFO:  reclustering "_timescaledb_internal._hyper_1_1_chunk" using index scan on "_hyper_1_1_chunk_cluster_test_time_idx"
INFO:  "_hyper_1_1_chunk": found 0 removable, 1 nonremovable row versions in 1 pages
-- after each test we ensure bitmap scans work
BEGIN;
    SET LOCAL enable_seqscan=false;
    SET LOCAL enable_indexscan=false;
    SET LOCAL enable_bitmapscan=true;
    EXPLAIN (costs off) SELECT * FROM cluster_test WHERE time='2017-01-21T09:00:01';
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 Append
   ->  Bitmap Heap Scan on cluster_test
         Recheck Cond: ("time" = 'Sat Jan 21 09:00:01 2017 PST'::timestamp with time zone)
         ->  Bitmap Index Scan on cluster_test_time_idx
               Index Cond: ("time" = 'Sat Jan 21 09:00:01 2017 PST'::timestamp with time zone)
   ->  Bitmap Heap Scan on _hyper_1_2_chunk
         Recheck Cond: ("time" = 'Sat Jan 21 09:00:01 2017 PST'::timestamp with time zone)
         ->  Bitmap Index Scan on _hyper_1_2_chunk_cluster_test_time_idx
               Index Cond: ("time" = 'Sat Jan 21 09:00:01 2017 PST'::timestamp with time zone)
(9 rows)

    SELECT * FROM cluster_test WHERE time='2017-01-21T09:00:01';
             time             | temp | location 
------------------------------+------+----------
 Sat Jan 21 09:00:01 2017 PST | 21.3 |        2
(1 row)

COMMIT;
-- after each test we ensure index scans work
BEGIN;
    SET LOCAL enable_seqscan=false;
    SET LOCAL enable_indexscan=true;
    SET LOCAL enable_bitmapscan=false;
    EXPLAIN (costs off) SELECT * FROM cluster_test WHERE time='2017-01-21T09:00:01';
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Append
   ->  Index Scan using cluster_test_time_idx on cluster_test
         Index Cond: ("time" = 'Sat Jan 21 09:00:01 2017 PST'::timestamp with time zone)
   ->  Index Scan using _hyper_1_2_chunk_cluster_test_time_idx on _hyper_1_2_chunk
         Index Cond: ("time" = 'Sat Jan 21 09:00:01 2017 PST'::timestamp with time zone)
(5 rows)

    SELECT * FROM cluster_test WHERE time='2017-01-21T09:00:01';
             time             | temp | location 
------------------------------+------+----------
 Sat Jan 21 09:00:01 2017 PST | 21.3 |        2
(1 row)

COMMIT;
-- after each test we ensure sequntial scans work
BEGIN;
    SET LOCAL enable_seqscan=true;
    SET LOCAL enable_indexscan=false;
    SET LOCAL enable_bitmapscan=false;
    EXPLAIN (costs off) SELECT * FROM cluster_test WHERE time='2017-01-21T09:00:01';
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Append
   ->  Seq Scan on cluster_test
         Filter: ("time" = 'Sat Jan 21 09:00:01 2017 PST'::timestamp with time zone)
   ->  Seq Scan on _hyper_1_2_chunk
         Filter: ("time" = 'Sat Jan 21 09:00:01 2017 PST'::timestamp with time zone)
(5 rows)

    SELECT * FROM cluster_test WHERE time='2017-01-21T09:00:01';
             time             | temp | location 
------------------------------+------+----------
 Sat Jan 21 09:00:01 2017 PST | 21.3 |        2
(1 row)

COMMIT;
-- Create a third chunk
INSERT INTO cluster_test VALUES ('2017-01-22T09:00:01', 19.5, 3);
-- Show clustered indexes
SELECT indexrelid::regclass, indisclustered
FROM pg_index
WHERE indisclustered = true;
                          indexrelid                          | indisclustered 
--------------------------------------------------------------+----------------
 _timescaledb_internal._hyper_1_2_chunk_cluster_test_time_idx | t
 _timescaledb_internal._hyper_1_1_chunk_cluster_test_time_idx | t
 cluster_test_time_idx                                        | t
(3 rows)

-- Recluster just our table
CLUSTER VERBOSE cluster_test;
INFO:  reclustering "_timescaledb_internal._hyper_1_3_chunk" using index scan on "_hyper_1_3_chunk_cluster_test_time_idx"
INFO:  "_hyper_1_3_chunk": found 0 removable, 1 nonremovable row versions in 1 pages
INFO:  reclustering "_timescaledb_internal._hyper_1_2_chunk" using sequential scan and sort
INFO:  "_hyper_1_2_chunk": found 0 removable, 1 nonremovable row versions in 1 pages
INFO:  reclustering "_timescaledb_internal._hyper_1_1_chunk" using sequential scan and sort
INFO:  "_hyper_1_1_chunk": found 0 removable, 1 nonremovable row versions in 1 pages
-- after each test we ensure bitmap scans work
BEGIN;
    SET LOCAL enable_seqscan=false;
    SET LOCAL enable_indexscan=false;
    SET LOCAL enable_bitmapscan=true;
    EXPLAIN (costs off) SELECT * FROM cluster_test WHERE time='2017-01-21T09:00:01';
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 Append
   ->  Bitmap Heap Scan on cluster_test
         Recheck Cond: ("time" = 'Sat Jan 21 09:00:01 2017 PST'::timestamp with time zone)
         ->  Bitmap Index Scan on cluster_test_time_idx
               Index Cond: ("time" = 'Sat Jan 21 09:00:01 2017 PST'::timestamp with time zone)
   ->  Bitmap Heap Scan on _hyper_1_2_chunk
         Recheck Cond: ("time" = 'Sat Jan 21 09:00:01 2017 PST'::timestamp with time zone)
         ->  Bitmap Index Scan on _hyper_1_2_chunk_cluster_test_time_idx
               Index Cond: ("time" = 'Sat Jan 21 09:00:01 2017 PST'::timestamp with time zone)
(9 rows)

    SELECT * FROM cluster_test WHERE time='2017-01-21T09:00:01';
             time             | temp | location 
------------------------------+------+----------
 Sat Jan 21 09:00:01 2017 PST | 21.3 |        2
(1 row)

COMMIT;
-- after each test we ensure index scans work
BEGIN;
    SET LOCAL enable_seqscan=false;
    SET LOCAL enable_indexscan=true;
    SET LOCAL enable_bitmapscan=false;
    EXPLAIN (costs off) SELECT * FROM cluster_test WHERE time='2017-01-21T09:00:01';
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Append
   ->  Index Scan using cluster_test_time_idx on cluster_test
         Index Cond: ("time" = 'Sat Jan 21 09:00:01 2017 PST'::timestamp with time zone)
   ->  Index Scan using _hyper_1_2_chunk_cluster_test_time_idx on _hyper_1_2_chunk
         Index Cond: ("time" = 'Sat Jan 21 09:00:01 2017 PST'::timestamp with time zone)
(5 rows)

    SELECT * FROM cluster_test WHERE time='2017-01-21T09:00:01';
             time             | temp | location 
------------------------------+------+----------
 Sat Jan 21 09:00:01 2017 PST | 21.3 |        2
(1 row)

COMMIT;
-- after each test we ensure sequntial scans work
BEGIN;
    SET LOCAL enable_seqscan=true;
    SET LOCAL enable_indexscan=false;
    SET LOCAL enable_bitmapscan=false;
    EXPLAIN (costs off) SELECT * FROM cluster_test WHERE time='2017-01-21T09:00:01';
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Append
   ->  Seq Scan on cluster_test
         Filter: ("time" = 'Sat Jan 21 09:00:01 2017 PST'::timestamp with time zone)
   ->  Seq Scan on _hyper_1_2_chunk
         Filter: ("time" = 'Sat Jan 21 09:00:01 2017 PST'::timestamp with time zone)
(5 rows)

    SELECT * FROM cluster_test WHERE time='2017-01-21T09:00:01';
             time             | temp | location 
------------------------------+------+----------
 Sat Jan 21 09:00:01 2017 PST | 21.3 |        2
(1 row)

COMMIT;
-- Show clustered indexes, including new chunk
SELECT indexrelid::regclass, indisclustered
FROM pg_index
WHERE indisclustered = true;
                          indexrelid                          | indisclustered 
--------------------------------------------------------------+----------------
 _timescaledb_internal._hyper_1_2_chunk_cluster_test_time_idx | t
 _timescaledb_internal._hyper_1_1_chunk_cluster_test_time_idx | t
 cluster_test_time_idx                                        | t
 _timescaledb_internal._hyper_1_3_chunk_cluster_test_time_idx | t
(4 rows)

-- Recluster all tables (although will only be our test table)
CLUSTER VERBOSE;
INFO:  clustering "_timescaledb_internal._hyper_1_3_chunk" using sequential scan and sort
INFO:  "_hyper_1_3_chunk": found 0 removable, 1 nonremovable row versions in 1 pages
INFO:  clustering "public.cluster_test" using sequential scan and sort
INFO:  "cluster_test": found 0 removable, 0 nonremovable row versions in 0 pages
INFO:  clustering "_timescaledb_internal._hyper_1_1_chunk" using sequential scan and sort
INFO:  "_hyper_1_1_chunk": found 0 removable, 1 nonremovable row versions in 1 pages
INFO:  clustering "_timescaledb_internal._hyper_1_2_chunk" using sequential scan and sort
INFO:  "_hyper_1_2_chunk": found 0 removable, 1 nonremovable row versions in 1 pages
-- after each test we ensure bitmap scans work
BEGIN;
    SET LOCAL enable_seqscan=false;
    SET LOCAL enable_indexscan=false;
    SET LOCAL enable_bitmapscan=true;
    EXPLAIN (costs off) SELECT * FROM cluster_test WHERE time='2017-01-21T09:00:01';
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 Append
   ->  Bitmap Heap Scan on cluster_test
         Recheck Cond: ("time" = 'Sat Jan 21 09:00:01 2017 PST'::timestamp with time zone)
         ->  Bitmap Index Scan on cluster_test_time_idx
               Index Cond: ("time" = 'Sat Jan 21 09:00:01 2017 PST'::timestamp with time zone)
   ->  Bitmap Heap Scan on _hyper_1_2_chunk
         Recheck Cond: ("time" = 'Sat Jan 21 09:00:01 2017 PST'::timestamp with time zone)
         ->  Bitmap Index Scan on _hyper_1_2_chunk_cluster_test_time_idx
               Index Cond: ("time" = 'Sat Jan 21 09:00:01 2017 PST'::timestamp with time zone)
(9 rows)

    SELECT * FROM cluster_test WHERE time='2017-01-21T09:00:01';
             time             | temp | location 
------------------------------+------+----------
 Sat Jan 21 09:00:01 2017 PST | 21.3 |        2
(1 row)

COMMIT;
-- after each test we ensure index scans work
BEGIN;
    SET LOCAL enable_seqscan=false;
    SET LOCAL enable_indexscan=true;
    SET LOCAL enable_bitmapscan=false;
    EXPLAIN (costs off) SELECT * FROM cluster_test WHERE time='2017-01-21T09:00:01';
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Append
   ->  Index Scan using cluster_test_time_idx on cluster_test
         Index Cond: ("time" = 'Sat Jan 21 09:00:01 2017 PST'::timestamp with time zone)
   ->  Index Scan using _hyper_1_2_chunk_cluster_test_time_idx on _hyper_1_2_chunk
         Index Cond: ("time" = 'Sat Jan 21 09:00:01 2017 PST'::timestamp with time zone)
(5 rows)

    SELECT * FROM cluster_test WHERE time='2017-01-21T09:00:01';
             time             | temp | location 
------------------------------+------+----------
 Sat Jan 21 09:00:01 2017 PST | 21.3 |        2
(1 row)

COMMIT;
-- after each test we ensure sequntial scans work
BEGIN;
    SET LOCAL enable_seqscan=true;
    SET LOCAL enable_indexscan=false;
    SET LOCAL enable_bitmapscan=false;
    EXPLAIN (costs off) SELECT * FROM cluster_test WHERE time='2017-01-21T09:00:01';
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Append
   ->  Seq Scan on cluster_test
         Filter: ("time" = 'Sat Jan 21 09:00:01 2017 PST'::timestamp with time zone)
   ->  Seq Scan on _hyper_1_2_chunk
         Filter: ("time" = 'Sat Jan 21 09:00:01 2017 PST'::timestamp with time zone)
(5 rows)

    SELECT * FROM cluster_test WHERE time='2017-01-21T09:00:01';
             time             | temp | location 
------------------------------+------+----------
 Sat Jan 21 09:00:01 2017 PST | 21.3 |        2
(1 row)

COMMIT;
-- Change the clustered index
CREATE INDEX ON cluster_test (time, location);
CLUSTER VERBOSE cluster_test USING cluster_test_time_location_idx;
INFO:  reclustering "_timescaledb_internal._hyper_1_3_chunk" using sequential scan and sort
INFO:  "_hyper_1_3_chunk": found 0 removable, 1 nonremovable row versions in 1 pages
INFO:  reclustering "_timescaledb_internal._hyper_1_2_chunk" using sequential scan and sort
INFO:  "_hyper_1_2_chunk": found 0 removable, 1 nonremovable row versions in 1 pages
INFO:  reclustering "_timescaledb_internal._hyper_1_1_chunk" using sequential scan and sort
INFO:  "_hyper_1_1_chunk": found 0 removable, 1 nonremovable row versions in 1 pages
-- after each test we ensure bitmap scans work
BEGIN;
    SET LOCAL enable_seqscan=false;
    SET LOCAL enable_indexscan=false;
    SET LOCAL enable_bitmapscan=true;
    EXPLAIN (costs off) SELECT * FROM cluster_test WHERE time='2017-01-21T09:00:01';
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 Append
   ->  Bitmap Heap Scan on cluster_test
         Recheck Cond: ("time" = 'Sat Jan 21 09:00:01 2017 PST'::timestamp with time zone)
         ->  Bitmap Index Scan on cluster_test_time_location_idx
               Index Cond: ("time" = 'Sat Jan 21 09:00:01 2017 PST'::timestamp with time zone)
   ->  Bitmap Heap Scan on _hyper_1_2_chunk
         Recheck Cond: ("time" = 'Sat Jan 21 09:00:01 2017 PST'::timestamp with time zone)
         ->  Bitmap Index Scan on _hyper_1_2_chunk_time_location_idx
               Index Cond: ("time" = 'Sat Jan 21 09:00:01 2017 PST'::timestamp with time zone)
(9 rows)

    SELECT * FROM cluster_test WHERE time='2017-01-21T09:00:01';
             time             | temp | location 
------------------------------+------+----------
 Sat Jan 21 09:00:01 2017 PST | 21.3 |        2
(1 row)

COMMIT;
-- after each test we ensure index scans work
BEGIN;
    SET LOCAL enable_seqscan=false;
    SET LOCAL enable_indexscan=true;
    SET LOCAL enable_bitmapscan=false;
    EXPLAIN (costs off) SELECT * FROM cluster_test WHERE time='2017-01-21T09:00:01';
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Append
   ->  Index Scan using cluster_test_time_location_idx on cluster_test
         Index Cond: ("time" = 'Sat Jan 21 09:00:01 2017 PST'::timestamp with time zone)
   ->  Index Scan using _hyper_1_2_chunk_time_location_idx on _hyper_1_2_chunk
         Index Cond: ("time" = 'Sat Jan 21 09:00:01 2017 PST'::timestamp with time zone)
(5 rows)

    SELECT * FROM cluster_test WHERE time='2017-01-21T09:00:01';
             time             | temp | location 
------------------------------+------+----------
 Sat Jan 21 09:00:01 2017 PST | 21.3 |        2
(1 row)

COMMIT;
-- after each test we ensure sequntial scans work
BEGIN;
    SET LOCAL enable_seqscan=true;
    SET LOCAL enable_indexscan=false;
    SET LOCAL enable_bitmapscan=false;
    EXPLAIN (costs off) SELECT * FROM cluster_test WHERE time='2017-01-21T09:00:01';
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Append
   ->  Seq Scan on cluster_test
         Filter: ("time" = 'Sat Jan 21 09:00:01 2017 PST'::timestamp with time zone)
   ->  Seq Scan on _hyper_1_2_chunk
         Filter: ("time" = 'Sat Jan 21 09:00:01 2017 PST'::timestamp with time zone)
(5 rows)

    SELECT * FROM cluster_test WHERE time='2017-01-21T09:00:01';
             time             | temp | location 
------------------------------+------+----------
 Sat Jan 21 09:00:01 2017 PST | 21.3 |        2
(1 row)

COMMIT;
-- Show updated clustered indexes
SELECT indexrelid::regclass, indisclustered
FROM pg_index
WHERE indisclustered = true;
                        indexrelid                        | indisclustered 
----------------------------------------------------------+----------------
 _timescaledb_internal._hyper_1_3_chunk_time_location_idx | t
 _timescaledb_internal._hyper_1_2_chunk_time_location_idx | t
 _timescaledb_internal._hyper_1_1_chunk_time_location_idx | t
 cluster_test_time_location_idx                           | t
(4 rows)

-- CLUSTER a chunk directly
CLUSTER VERBOSE _timescaledb_internal._hyper_1_2_chunk;
INFO:  reclustering "_timescaledb_internal._hyper_1_2_chunk" using sequential scan and sort
INFO:  "_hyper_1_2_chunk": found 0 removable, 1 nonremovable row versions in 1 pages
-- CLUSTER a chunk directly with an explicit index
CLUSTER VERBOSE _timescaledb_internal._hyper_1_2_chunk using cluster_test_time_idx;
INFO:  reclustering "_timescaledb_internal._hyper_1_2_chunk" using sequential scan and sort
INFO:  "_hyper_1_2_chunk": found 0 removable, 1 nonremovable row versions in 1 pages
-- CLUSTER a chunk directly with an chunk index
CLUSTER VERBOSE _timescaledb_internal._hyper_1_2_chunk using _hyper_1_2_chunk_cluster_test_time_idx;
INFO:  reclustering "_timescaledb_internal._hyper_1_2_chunk" using sequential scan and sort
INFO:  "_hyper_1_2_chunk": found 0 removable, 1 nonremovable row versions in 1 pages
-- after each test we ensure bitmap scans work
BEGIN;
    SET LOCAL enable_seqscan=false;
    SET LOCAL enable_indexscan=false;
    SET LOCAL enable_bitmapscan=true;
    EXPLAIN (costs off) SELECT * FROM cluster_test WHERE time='2017-01-21T09:00:01';
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 Append
   ->  Bitmap Heap Scan on cluster_test
         Recheck Cond: ("time" = 'Sat Jan 21 09:00:01 2017 PST'::timestamp with time zone)
         ->  Bitmap Index Scan on cluster_test_time_location_idx
               Index Cond: ("time" = 'Sat Jan 21 09:00:01 2017 PST'::timestamp with time zone)
   ->  Bitmap Heap Scan on _hyper_1_2_chunk
         Recheck Cond: ("time" = 'Sat Jan 21 09:00:01 2017 PST'::timestamp with time zone)
         ->  Bitmap Index Scan on _hyper_1_2_chunk_time_location_idx
               Index Cond: ("time" = 'Sat Jan 21 09:00:01 2017 PST'::timestamp with time zone)
(9 rows)

    SELECT * FROM cluster_test WHERE time='2017-01-21T09:00:01';
             time             | temp | location 
------------------------------+------+----------
 Sat Jan 21 09:00:01 2017 PST | 21.3 |        2
(1 row)

COMMIT;
-- after each test we ensure index scans work
BEGIN;
    SET LOCAL enable_seqscan=false;
    SET LOCAL enable_indexscan=true;
    SET LOCAL enable_bitmapscan=false;
    EXPLAIN (costs off) SELECT * FROM cluster_test WHERE time='2017-01-21T09:00:01';
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Append
   ->  Index Scan using cluster_test_time_location_idx on cluster_test
         Index Cond: ("time" = 'Sat Jan 21 09:00:01 2017 PST'::timestamp with time zone)
   ->  Index Scan using _hyper_1_2_chunk_time_location_idx on _hyper_1_2_chunk
         Index Cond: ("time" = 'Sat Jan 21 09:00:01 2017 PST'::timestamp with time zone)
(5 rows)

    SELECT * FROM cluster_test WHERE time='2017-01-21T09:00:01';
             time             | temp | location 
------------------------------+------+----------
 Sat Jan 21 09:00:01 2017 PST | 21.3 |        2
(1 row)

COMMIT;
-- after each test we ensure sequntial scans work
BEGIN;
    SET LOCAL enable_seqscan=true;
    SET LOCAL enable_indexscan=false;
    SET LOCAL enable_bitmapscan=false;
    EXPLAIN (costs off) SELECT * FROM cluster_test WHERE time='2017-01-21T09:00:01';
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Append
   ->  Seq Scan on cluster_test
         Filter: ("time" = 'Sat Jan 21 09:00:01 2017 PST'::timestamp with time zone)
   ->  Seq Scan on _hyper_1_2_chunk
         Filter: ("time" = 'Sat Jan 21 09:00:01 2017 PST'::timestamp with time zone)
(5 rows)

    SELECT * FROM cluster_test WHERE time='2017-01-21T09:00:01';
             time             | temp | location 
------------------------------+------+----------
 Sat Jan 21 09:00:01 2017 PST | 21.3 |        2
(1 row)

COMMIT;
-- we should start read_optimized
SELECT setting FROM pg_settings WHERE name = 'timescaledb.cluster_method';
    setting     
----------------
 read_optimized
(1 row)

-- Set guc to run basic cluster
UPDATE pg_settings SET setting = 'native' WHERE name = 'timescaledb.cluster_method';
 set_config 
------------
 native
(1 row)

-- and old cluster should be run
CLUSTER VERBOSE cluster_test USING cluster_test_time_location_idx;
INFO:  clustering "_timescaledb_internal._hyper_1_3_chunk" using sequential scan and sort
INFO:  "_hyper_1_3_chunk": found 0 removable, 1 nonremovable row versions in 1 pages
INFO:  clustering "_timescaledb_internal._hyper_1_2_chunk" using sequential scan and sort
INFO:  "_hyper_1_2_chunk": found 0 removable, 1 nonremovable row versions in 1 pages
INFO:  clustering "_timescaledb_internal._hyper_1_1_chunk" using sequential scan and sort
INFO:  "_hyper_1_1_chunk": found 0 removable, 1 nonremovable row versions in 1 pages
CLUSTER VERBOSE _timescaledb_internal._hyper_1_2_chunk;
INFO:  clustering "_timescaledb_internal._hyper_1_2_chunk" using sequential scan and sort
INFO:  "_hyper_1_2_chunk": found 0 removable, 1 nonremovable row versions in 1 pages
-- after each test we ensure bitmap scans work
BEGIN;
    SET LOCAL enable_seqscan=false;
    SET LOCAL enable_indexscan=false;
    SET LOCAL enable_bitmapscan=true;
    EXPLAIN (costs off) SELECT * FROM cluster_test WHERE time='2017-01-21T09:00:01';
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 Append
   ->  Bitmap Heap Scan on cluster_test
         Recheck Cond: ("time" = 'Sat Jan 21 09:00:01 2017 PST'::timestamp with time zone)
         ->  Bitmap Index Scan on cluster_test_time_location_idx
               Index Cond: ("time" = 'Sat Jan 21 09:00:01 2017 PST'::timestamp with time zone)
   ->  Bitmap Heap Scan on _hyper_1_2_chunk
         Recheck Cond: ("time" = 'Sat Jan 21 09:00:01 2017 PST'::timestamp with time zone)
         ->  Bitmap Index Scan on _hyper_1_2_chunk_time_location_idx
               Index Cond: ("time" = 'Sat Jan 21 09:00:01 2017 PST'::timestamp with time zone)
(9 rows)

    SELECT * FROM cluster_test WHERE time='2017-01-21T09:00:01';
             time             | temp | location 
------------------------------+------+----------
 Sat Jan 21 09:00:01 2017 PST | 21.3 |        2
(1 row)

COMMIT;
-- after each test we ensure index scans work
BEGIN;
    SET LOCAL enable_seqscan=false;
    SET LOCAL enable_indexscan=true;
    SET LOCAL enable_bitmapscan=false;
    EXPLAIN (costs off) SELECT * FROM cluster_test WHERE time='2017-01-21T09:00:01';
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Append
   ->  Index Scan using cluster_test_time_location_idx on cluster_test
         Index Cond: ("time" = 'Sat Jan 21 09:00:01 2017 PST'::timestamp with time zone)
   ->  Index Scan using _hyper_1_2_chunk_time_location_idx on _hyper_1_2_chunk
         Index Cond: ("time" = 'Sat Jan 21 09:00:01 2017 PST'::timestamp with time zone)
(5 rows)

    SELECT * FROM cluster_test WHERE time='2017-01-21T09:00:01';
             time             | temp | location 
------------------------------+------+----------
 Sat Jan 21 09:00:01 2017 PST | 21.3 |        2
(1 row)

COMMIT;
-- after each test we ensure sequntial scans work
BEGIN;
    SET LOCAL enable_seqscan=true;
    SET LOCAL enable_indexscan=false;
    SET LOCAL enable_bitmapscan=false;
    EXPLAIN (costs off) SELECT * FROM cluster_test WHERE time='2017-01-21T09:00:01';
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Append
   ->  Seq Scan on cluster_test
         Filter: ("time" = 'Sat Jan 21 09:00:01 2017 PST'::timestamp with time zone)
   ->  Seq Scan on _hyper_1_2_chunk
         Filter: ("time" = 'Sat Jan 21 09:00:01 2017 PST'::timestamp with time zone)
(5 rows)

    SELECT * FROM cluster_test WHERE time='2017-01-21T09:00:01';
             time             | temp | location 
------------------------------+------+----------
 Sat Jan 21 09:00:01 2017 PST | 21.3 |        2
(1 row)

COMMIT;
-- Set guc back
UPDATE pg_settings SET setting = 'read_optimized' WHERE name = 'timescaledb.cluster_method';
   set_config   
----------------
 read_optimized
(1 row)

-- and new cluster should be run
CLUSTER VERBOSE cluster_test USING cluster_test_time_location_idx;
INFO:  reclustering "_timescaledb_internal._hyper_1_3_chunk" using sequential scan and sort
INFO:  "_hyper_1_3_chunk": found 0 removable, 1 nonremovable row versions in 1 pages
INFO:  reclustering "_timescaledb_internal._hyper_1_2_chunk" using sequential scan and sort
INFO:  "_hyper_1_2_chunk": found 0 removable, 1 nonremovable row versions in 1 pages
INFO:  reclustering "_timescaledb_internal._hyper_1_1_chunk" using sequential scan and sort
INFO:  "_hyper_1_1_chunk": found 0 removable, 1 nonremovable row versions in 1 pages
CLUSTER VERBOSE _timescaledb_internal._hyper_1_2_chunk;
INFO:  reclustering "_timescaledb_internal._hyper_1_2_chunk" using sequential scan and sort
INFO:  "_hyper_1_2_chunk": found 0 removable, 1 nonremovable row versions in 1 pages
-- after each test we ensure bitmap scans work
BEGIN;
    SET LOCAL enable_seqscan=false;
    SET LOCAL enable_indexscan=false;
    SET LOCAL enable_bitmapscan=true;
    EXPLAIN (costs off) SELECT * FROM cluster_test WHERE time='2017-01-21T09:00:01';
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 Append
   ->  Bitmap Heap Scan on cluster_test
         Recheck Cond: ("time" = 'Sat Jan 21 09:00:01 2017 PST'::timestamp with time zone)
         ->  Bitmap Index Scan on cluster_test_time_location_idx
               Index Cond: ("time" = 'Sat Jan 21 09:00:01 2017 PST'::timestamp with time zone)
   ->  Bitmap Heap Scan on _hyper_1_2_chunk
         Recheck Cond: ("time" = 'Sat Jan 21 09:00:01 2017 PST'::timestamp with time zone)
         ->  Bitmap Index Scan on _hyper_1_2_chunk_time_location_idx
               Index Cond: ("time" = 'Sat Jan 21 09:00:01 2017 PST'::timestamp with time zone)
(9 rows)

    SELECT * FROM cluster_test WHERE time='2017-01-21T09:00:01';
             time             | temp | location 
------------------------------+------+----------
 Sat Jan 21 09:00:01 2017 PST | 21.3 |        2
(1 row)

COMMIT;
-- after each test we ensure index scans work
BEGIN;
    SET LOCAL enable_seqscan=false;
    SET LOCAL enable_indexscan=true;
    SET LOCAL enable_bitmapscan=false;
    EXPLAIN (costs off) SELECT * FROM cluster_test WHERE time='2017-01-21T09:00:01';
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Append
   ->  Index Scan using cluster_test_time_location_idx on cluster_test
         Index Cond: ("time" = 'Sat Jan 21 09:00:01 2017 PST'::timestamp with time zone)
   ->  Index Scan using _hyper_1_2_chunk_time_location_idx on _hyper_1_2_chunk
         Index Cond: ("time" = 'Sat Jan 21 09:00:01 2017 PST'::timestamp with time zone)
(5 rows)

    SELECT * FROM cluster_test WHERE time='2017-01-21T09:00:01';
             time             | temp | location 
------------------------------+------+----------
 Sat Jan 21 09:00:01 2017 PST | 21.3 |        2
(1 row)

COMMIT;
-- after each test we ensure sequntial scans work
BEGIN;
    SET LOCAL enable_seqscan=true;
    SET LOCAL enable_indexscan=false;
    SET LOCAL enable_bitmapscan=false;
    EXPLAIN (costs off) SELECT * FROM cluster_test WHERE time='2017-01-21T09:00:01';
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Append
   ->  Seq Scan on cluster_test
         Filter: ("time" = 'Sat Jan 21 09:00:01 2017 PST'::timestamp with time zone)
   ->  Seq Scan on _hyper_1_2_chunk
         Filter: ("time" = 'Sat Jan 21 09:00:01 2017 PST'::timestamp with time zone)
(5 rows)

    SELECT * FROM cluster_test WHERE time='2017-01-21T09:00:01';
             time             | temp | location 
------------------------------+------+----------
 Sat Jan 21 09:00:01 2017 PST | 21.3 |        2
(1 row)

COMMIT;
-- test with TOAST (based on size_utils.sql)
CREATE TABLE toast_test(time TIMESTAMP, value TEXT);
-- Set storage type to EXTERNAL to prevent PostgreSQL from compressing my
-- easily compressable string and instead store it with TOAST
ALTER TABLE toast_test ALTER COLUMN value SET STORAGE EXTERNAL;
SELECT * FROM create_hypertable('toast_test', 'time');
NOTICE:  adding not-null constraint to column "time"
 create_hypertable 
-------------------
 
(1 row)

INSERT INTO toast_test VALUES('2004-10-19 10:23:54', $$
this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k.
$$);
SELECT * FROM toast_test;
           time           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    value                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    
--------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Tue Oct 19 10:23:54 2004 |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            +
                          | this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k.+
                          | 
(1 row)

CLUSTER VERBOSE toast_test USING toast_test_time_idx;
INFO:  reclustering "_timescaledb_internal._hyper_2_4_chunk" using index scan on "_hyper_2_4_chunk_toast_test_time_idx"
INFO:  "_hyper_2_4_chunk": found 0 removable, 1 nonremovable row versions in 1 pages
SELECT * FROM toast_test;
           time           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    value                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    
--------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Tue Oct 19 10:23:54 2004 |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            +
                          | this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k. this must be over 2k.+
                          | 
(1 row)

-- force CLUSTER to vaccum the toast_table
ALTER TABLE toast_test DROP COLUMN value;
SELECT * FROM toast_test;
           time           
--------------------------
 Tue Oct 19 10:23:54 2004
(1 row)

CLUSTER VERBOSE toast_test USING cluster_test_time_idx;
SELECT * FROM toast_test;
           time           
--------------------------
 Tue Oct 19 10:23:54 2004
(1 row)

-- after each test we ensure bitmap scans work
BEGIN;
    SET LOCAL enable_seqscan=false;
    SET LOCAL enable_indexscan=false;
    SET LOCAL enable_bitmapscan=true;
    EXPLAIN (costs off) SELECT * FROM cluster_test WHERE time='2004-10-19 10:23:54';
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 Append
   ->  Bitmap Heap Scan on cluster_test
         Recheck Cond: ("time" = 'Tue Oct 19 10:23:54 2004 PDT'::timestamp with time zone)
         ->  Bitmap Index Scan on cluster_test_time_location_idx
               Index Cond: ("time" = 'Tue Oct 19 10:23:54 2004 PDT'::timestamp with time zone)
(5 rows)

    SELECT * FROM toast_test WHERE time='2004-10-19 10:23:54';
           time           
--------------------------
 Tue Oct 19 10:23:54 2004
(1 row)

COMMIT;
-- after each test we ensure index scans work
BEGIN;
    SET LOCAL enable_seqscan=false;
    SET LOCAL enable_indexscan=true;
    SET LOCAL enable_bitmapscan=false;
    EXPLAIN (costs off) SELECT * FROM cluster_test WHERE time='2004-10-19 10:23:54';
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Append
   ->  Index Scan using cluster_test_time_location_idx on cluster_test
         Index Cond: ("time" = 'Tue Oct 19 10:23:54 2004 PDT'::timestamp with time zone)
(3 rows)

    SELECT * FROM toast_test WHERE time='2004-10-19 10:23:54';
           time           
--------------------------
 Tue Oct 19 10:23:54 2004
(1 row)

COMMIT;
-- after each test we ensure sequntial scans work
BEGIN;
    SET LOCAL enable_seqscan=true;
    SET LOCAL enable_indexscan=false;
    SET LOCAL enable_bitmapscan=false;
    EXPLAIN (costs off) SELECT * FROM cluster_test WHERE time='2004-10-19 10:23:54';
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Append
   ->  Seq Scan on cluster_test
         Filter: ("time" = 'Tue Oct 19 10:23:54 2004 PDT'::timestamp with time zone)
(3 rows)

    SELECT * FROM toast_test WHERE time='2004-10-19 10:23:54';
           time           
--------------------------
 Tue Oct 19 10:23:54 2004
(1 row)

COMMIT;
-- if we someone elses index error
CLUSTER VERBOSE toast_test USING cluster_test_time_idx;
--check the setting of cluster indexes on hypertables and chunks
ALTER TABLE cluster_test CLUSTER ON cluster_test_time_idx;
SELECT indexrelid::regclass, indisclustered
FROM pg_index
WHERE indisclustered = true
ORDER BY 1,2;
                          indexrelid                          | indisclustered 
--------------------------------------------------------------+----------------
 cluster_test_time_idx                                        | t
 _timescaledb_internal._hyper_1_1_chunk_cluster_test_time_idx | t
 _timescaledb_internal._hyper_1_2_chunk_cluster_test_time_idx | t
 _timescaledb_internal._hyper_1_3_chunk_cluster_test_time_idx | t
 _timescaledb_internal._hyper_2_4_chunk_toast_test_time_idx   | t
(5 rows)

CLUSTER VERBOSE cluster_test;
INFO:  reclustering "_timescaledb_internal._hyper_1_3_chunk" using sequential scan and sort
INFO:  "_hyper_1_3_chunk": found 0 removable, 1 nonremovable row versions in 1 pages
INFO:  reclustering "_timescaledb_internal._hyper_1_2_chunk" using sequential scan and sort
INFO:  "_hyper_1_2_chunk": found 0 removable, 1 nonremovable row versions in 1 pages
INFO:  reclustering "_timescaledb_internal._hyper_1_1_chunk" using sequential scan and sort
INFO:  "_hyper_1_1_chunk": found 0 removable, 1 nonremovable row versions in 1 pages
ALTER TABLE cluster_test SET WITHOUT CLUSTER;
SELECT indexrelid::regclass, indisclustered
FROM pg_index
WHERE indisclustered = true
ORDER BY 1,2;
                         indexrelid                         | indisclustered 
------------------------------------------------------------+----------------
 _timescaledb_internal._hyper_2_4_chunk_toast_test_time_idx | t
(1 row)

\set ON_ERROR_STOP 0
CLUSTER VERBOSE cluster_test;
ERROR:  there is no previously clustered index for table "cluster_test"
\set ON_ERROR_STOP 1
ALTER TABLE _timescaledb_internal._hyper_1_1_chunk CLUSTER ON _hyper_1_1_chunk_cluster_test_time_idx;
SELECT indexrelid::regclass, indisclustered
FROM pg_index
WHERE indisclustered = true
ORDER BY 1,2;
                          indexrelid                          | indisclustered 
--------------------------------------------------------------+----------------
 _timescaledb_internal._hyper_1_1_chunk_cluster_test_time_idx | t
 _timescaledb_internal._hyper_2_4_chunk_toast_test_time_idx   | t
(2 rows)

CLUSTER VERBOSE _timescaledb_internal._hyper_1_1_chunk;
INFO:  reclustering "_timescaledb_internal._hyper_1_1_chunk" using sequential scan and sort
INFO:  "_hyper_1_1_chunk": found 0 removable, 1 nonremovable row versions in 1 pages
ALTER TABLE _timescaledb_internal._hyper_1_1_chunk SET WITHOUT CLUSTER;
SELECT indexrelid::regclass, indisclustered
FROM pg_index
WHERE indisclustered = true
ORDER BY 1,2;
                         indexrelid                         | indisclustered 
------------------------------------------------------------+----------------
 _timescaledb_internal._hyper_2_4_chunk_toast_test_time_idx | t
(1 row)

\set ON_ERROR_STOP 0
CLUSTER VERBOSE _timescaledb_internal._hyper_1_1_chunk;
ERROR:  there is no previously clustered index for table "_hyper_1_1_chunk"
\set ON_ERROR_STOP 1
